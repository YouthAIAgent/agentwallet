#!/usr/bin/env bash
# AgentWallet CLI — ./aw [command]
# No args → interactive menu  |  ./aw help → all commands

# ── Colors ────────────────────────────────────────────────────────────────────
BGREEN='\033[1;32m'
GREEN='\033[0;32m'
BCYAN='\033[1;36m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
BYELLOW='\033[1;33m'
WHITE='\033[1;37m'
DIM='\033[2m'
RED='\033[0;31m'
BOLD='\033[1m'
NC='\033[0m'

CMD="${1:-menu}"

# ── Python detection (verify it actually runs, not just a Windows Store stub) ─
PYTHON=""
if python3 --version >/dev/null 2>&1; then
  PYTHON=python3
elif python --version >/dev/null 2>&1; then
  PYTHON=python
fi

# ── Session ───────────────────────────────────────────────────────────────────
SESSION_FILE="$(dirname "$0")/.aw_session"
AW_TOKEN=""
AW_EMAIL=""
AW_ORG_ID=""
AW_API="${AW_API:-http://localhost:8000}"

load_session()  { [ -f "$SESSION_FILE" ] && source "$SESSION_FILE" 2>/dev/null; }
save_session()  {
  printf 'AW_TOKEN="%s"\nAW_EMAIL="%s"\nAW_ORG_ID="%s"\n' \
    "$AW_TOKEN" "$AW_EMAIL" "$AW_ORG_ID" > "$SESSION_FILE"
  chmod 600 "$SESSION_FILE" 2>/dev/null
}
clear_session() { AW_TOKEN=""; AW_EMAIL=""; AW_ORG_ID=""; rm -f "$SESSION_FILE"; }

# ── API call ──────────────────────────────────────────────────────────────────
# Sets HTTP_CODE and RESPONSE globals
api_call() {
  local method="$1" path="$2" body="${3:-}"
  local url="${AW_API}/v1${path}"
  local tmp
  tmp=$(mktemp 2>/dev/null || echo "/tmp/aw_$$")

  local auth_args=()
  [ -n "$AW_TOKEN" ] && auth_args+=(-H "Authorization: Bearer $AW_TOKEN")

  if [ -n "$body" ]; then
    HTTP_CODE=$(curl -s -o "$tmp" -w "%{http_code}" -X "$method" "$url" \
      -H "Content-Type: application/json" "${auth_args[@]}" -d "$body" 2>/dev/null)
  else
    HTTP_CODE=$(curl -s -o "$tmp" -w "%{http_code}" -X "$method" "$url" \
      "${auth_args[@]}" 2>/dev/null)
  fi
  RESPONSE=$(cat "$tmp" 2>/dev/null)
  rm -f "$tmp" 2>/dev/null
}

# ── Pure-bash JSON builder — no Python needed ─────────────────────────────────
# Usage: make_json key1 val1 key2 val2 ...
make_json() {
  local json="{" sep=""
  while [ $# -ge 2 ]; do
    local k="$1" v="$2"; shift 2
    # numeric?
    if printf '%s' "$v" | grep -qE '^[0-9]+(\.[0-9]+)?$' 2>/dev/null; then
      json="${json}${sep}\"${k}\":${v}"
    else
      local esc="${v//\\/\\\\}"; esc="${esc//\"/\\\"}"
      json="${json}${sep}\"${k}\":\"${esc}\""
    fi
    sep=","
  done
  printf '%s' "${json}}"
}

# ── JSON field extractor (Python-powered, silent fail) ────────────────────────
json_field() {
  [ -z "$PYTHON" ] && { printf ''; return; }
  printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys, json
try:
    d = json.load(sys.stdin)
    keys = '$1'.split('.')
    for k in keys:
        if isinstance(d, list): d = d[int(k)]
        else: d = d.get(k, '')
    v = d if d is not None else ''
    print(v)
except: print('')" 2>/dev/null
}

# ── Human-readable error from RESPONSE (handles Pydantic list detail) ─────────
api_error() {
  if [ -n "$PYTHON" ]; then
    printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys, json
try:
    d = json.load(sys.stdin)
    detail = d.get('detail', '')
    if isinstance(detail, list):
        msgs = [item.get('msg', str(item)) for item in detail]
        print(' | '.join(msgs))
    else:
        print(str(detail) if detail else 'check API is running')
except: print('$RESPONSE')" 2>/dev/null
  else
    printf '%s' "$RESPONSE"
  fi
}

# ── Check API up ──────────────────────────────────────────────────────────────
check_api() {
  local s
  s=$(curl -s -o /dev/null -w "%{http_code}" "${AW_API}/health" 2>/dev/null || echo "000")
  [ "$s" = "200" ]
}

# ── UI helpers ────────────────────────────────────────────────────────────────
sep()   { printf "  ${DIM}──────────────────────────────────────────────${NC}\n"; }
ok()    { printf "  ${BGREEN}[OK]${NC}  $1\n"; }
err()   { printf "  ${RED}[ERR]${NC} $1\n"; }
info()  { printf "  ${CYAN}[..]${NC}  $1\n"; }
pause() { printf "\n  ${DIM}Press Enter to continue...${NC}"; read -r _; }

prompt() {
  printf "  ${YELLOW}>>${NC} ${BOLD}$1${NC}: "
  read -r "$2"
}
prompt_secret() {
  printf "  ${YELLOW}>>${NC} ${BOLD}$1${NC}: "
  if [ -t 0 ]; then read -rs "$2"; printf "\n"; else read -r "$2"; fi
}

# ── Intro banner (shown once when menu starts) ────────────────────────────────
show_intro() {
  if [ -n "$PYTHON" ]; then
    PYTHONUTF8=1 PYTHONIOENCODING=utf-8 "$PYTHON" - <<'PYEOF'
import sys, os, random, time
try:
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')
except Exception:
    pass

G  = "\033[1;32m"
Y  = "\033[1;33m"
C  = "\033[1;36m"
DIM = "\033[2m"
R  = "\033[0m"

try:
    cols = os.get_terminal_size().columns
except Exception:
    cols = 80
cols = min(cols, 100)

# matrix rain
chars = "01ABCDEF0123456789#@!$%&*"
for _ in range(4):
    line = "".join(random.choice(chars) for _ in range(cols))
    sys.stdout.write(f"{G}{line}{R}\n")
    sys.stdout.flush()
    time.sleep(0.05)
print()

# AGENT (yellow)
agent = [
    "    \u2588\u2588\u2588\u2588\u2588\u256d  \u2588\u2588\u2588\u2588\u2588\u2588\u256d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d\u2588\u2588\u2588\u256d   \u2588\u2588\u256d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d",
    "   \u2588\u2588\u256f\u2500\u2500\u2588\u2588\u256d\u2588\u2588\u256f\u2550\u2550\u2550\u2550\u256d \u2588\u2588\u256f\u2550\u2550\u2550\u2550\u256d\u2588\u2588\u2588\u2588\u256d  \u2588\u2588\u256d\u255a\u2550\u2550\u2588\u2588\u256f\u2550\u2550\u256d",
    "   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d\u2588\u2588\u256d  \u2588\u2588\u2588\u256d\u2588\u2588\u2588\u2588\u2588\u256d  \u2588\u2588\u256f\u2588\u2588\u256f \u2588\u2588\u256d   \u2588\u2588\u256d   ",
    "   \u2588\u2588\u256f\u2500\u2500\u2588\u2588\u256d\u2588\u2588\u256d   \u2588\u2588\u256d\u2588\u2588\u256f\u2500\u2500\u256d  \u2588\u2588\u256d\u255a\u2588\u2588\u256d   \u2588\u2588\u256d   ",
    "   \u2588\u2588\u256d  \u2588\u2588\u256d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u256f\u256d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d\u2588\u2588\u256d \u255a\u2588\u2588\u2588\u2588\u256d   \u2588\u2588\u256d   ",
    "   \u255a\u2550\u256d  \u255a\u2550\u256d \u255a\u2550\u2550\u2550\u2550\u2550\u256f \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u256d\u255a\u2550\u256d  \u255a\u2550\u2550\u2550\u256d   \u255a\u2550\u256d   ",
]
for line in agent:
    print(f"{Y}  {line}{R}")
print()

# WALLET (green)
wallet = [
    "   \u2588\u2588\u256d    \u2588\u2588\u256d \u2588\u2588\u2588\u2588\u2588\u256d \u2588\u2588\u256d     \u2588\u2588\u256d     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d",
    "   \u2588\u2588\u256d    \u2588\u2588\u256d\u2588\u2588\u256f\u2500\u2500\u2588\u2588\u256d\u2588\u2588\u256d     \u2588\u2588\u256d     \u2588\u2588\u256f\u2550\u2550\u2550\u2550\u256d\u255a\u2550\u2550\u2588\u2588\u256f\u2500\u2500\u256d",
    "   \u2588\u2588\u256d \u2588\u256d \u2588\u2588\u256d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d\u2588\u2588\u256d     \u2588\u2588\u256d     \u2588\u2588\u2588\u2588\u2588\u256d     \u2588\u2588\u256d   ",
    "   \u2588\u2588\u256d\u2588\u2588\u2588\u256d\u2588\u2588\u256d\u2588\u2588\u256f\u2500\u2500\u2588\u2588\u256d\u2588\u2588\u256d     \u2588\u2588\u256d     \u2588\u2588\u256f\u2500\u2500\u256d     \u2588\u2588\u256d   ",
    "   \u255a\u2588\u2588\u2588\u256f\u2588\u2588\u2588\u256f\u2588\u2588\u256d  \u2588\u2588\u256d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u256d   \u2588\u2588\u256d   ",
    "    \u255a\u2550\u2550\u256d\u255a\u2550\u2550\u256d \u255a\u2550\u256d  \u255a\u2550\u256d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u256d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u256d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u256d   \u255a\u2550\u256d   ",
]
for line in wallet:
    print(f"{G}  {line}{R}")
print()

# tagline box
line = "\u2500" * 58
print(f"{DIM}   \u250c{line}\u2510{R}")
print(f"{DIM}   \u2502{R}  {G}Give your AI agent a wallet.{R}                          {DIM}\u2502{R}")
print(f"{DIM}   \u2502{R}  {DIM}Solana \u00b7 Escrow \u00b7 ACP \u00b7 Swarms \u00b7 v0.4.0 \u00b7 MIT{R}        {DIM}\u2502{R}")
print(f"{DIM}   \u2514{line}\u2518{R}")
print()
PYEOF

  else
    # Python not available — ASCII fallback
    printf "\n"
    printf "  ${BYELLOW}  ___   ___ ___ _  _ _____   __      ___   _    _    ___ _____${NC}\n"
    printf "  ${BYELLOW} / _ \ / __| __| \| |_   _|  \ \    / /_\ | |  | |  | __|_   _|${NC}\n"
    printf "  ${BGREEN}| (_) | (_ | _|| .\` | | |    \ \/\/ / _ \| |__| |__| _|   | |${NC}\n"
    printf "  ${BGREEN} \___/ \___|___|_|\_| |_|     \_/\_/_/ \_\____|____|___|   |_|${NC}\n"
    printf "\n"
    printf "  ${DIM}Give your AI agent a wallet. v0.4.0${NC}\n"
    printf "\n"
  fi
}

# ── Compact menu header (shown each loop) ─────────────────────────────────────
print_menu_header() {
  local api_status="${RED}[DOWN]${NC}"
  check_api 2>/dev/null && api_status="${BGREEN}[ UP ]${NC}"

  local auth_info="${DIM}not logged in${NC}"
  [ -n "$AW_TOKEN" ] && [ -n "$AW_EMAIL" ] && \
    auth_info="${BGREEN}logged in${NC} ${DIM}as${NC} ${WHITE}${AW_EMAIL}${NC}"

  printf "\n"
  printf "  ${BYELLOW}// AGENT WALLET${NC}  ${DIM}v0.4.0${NC}  ${DIM}·${NC}  ${AW_API}\n"
  printf "  ${DIM}API:${NC} ${api_status}   ${DIM}Auth:${NC} ${auth_info}\n"
  sep
}

# ── Flow: Register ────────────────────────────────────────────────────────────
flow_register() {
  printf "\n  ${BYELLOW}>> REGISTER${NC}\n"; sep

  prompt "Organization name (e.g. MyStartup AI)" ORG_NAME
  prompt "Email" R_EMAIL
  printf "  ${DIM}   Password: 8+ chars, uppercase, lowercase, digit, special (!@#\$)${NC}\n"
  prompt_secret "Password" R_PASS

  info "Creating account..."
  local body
  body=$(make_json "org_name" "$ORG_NAME" "email" "$R_EMAIL" "password" "$R_PASS")
  api_call POST /auth/register "$body"

  if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
    AW_TOKEN=$(json_field "access_token")
    AW_ORG_ID=$(json_field "org_id")
    AW_EMAIL="$R_EMAIL"
    save_session
    printf "\n"
    ok "Account created! Logged in as ${WHITE}${AW_EMAIL}${NC}"
    [ -n "$AW_ORG_ID" ] && ok "Org ID: ${CYAN}${AW_ORG_ID}${NC}"
  else
    err "Registration failed (HTTP $HTTP_CODE): $(api_error)"
  fi
  pause
}

# ── Flow: Login ───────────────────────────────────────────────────────────────
flow_login() {
  printf "\n  ${BYELLOW}>> LOGIN${NC}\n"; sep

  prompt "Email" L_EMAIL
  prompt_secret "Password" L_PASS

  info "Logging in..."
  local body
  body=$(make_json "email" "$L_EMAIL" "password" "$L_PASS")
  api_call POST /auth/login "$body"

  if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
    AW_TOKEN=$(json_field "access_token")
    AW_ORG_ID=$(json_field "org_id")
    AW_EMAIL="$L_EMAIL"
    save_session
    printf "\n"
    ok "Logged in as ${WHITE}${AW_EMAIL}${NC}"
  else
    err "Login failed (HTTP $HTTP_CODE): $(api_error)"
  fi
  pause
}

# ── Flow: Logout ──────────────────────────────────────────────────────────────
flow_logout() {
  clear_session
  ok "Logged out."
  pause
}

# ── Flow: Create Wallet ───────────────────────────────────────────────────────
flow_create_wallet() {
  [ -z "$AW_TOKEN" ] && { err "Login first (option 2)"; pause; return; }

  printf "\n  ${BYELLOW}>> CREATE WALLET${NC}\n"; sep

  prompt "Wallet label (e.g. Trading Bot Wallet)" W_LABEL

  printf "\n"
  printf "  ${DIM}Wallet type:${NC}\n"
  printf "  ${YELLOW}[1]${NC} Agent   ${DIM}(default — for AI agent operations)${NC}\n"
  printf "  ${YELLOW}[2]${NC} Treasury ${DIM}(org-level treasury wallet)${NC}\n"
  printf "  ${YELLOW}[3]${NC} Escrow  ${DIM}(for escrow-held funds)${NC}\n"
  printf "  ${YELLOW}>>${NC} Choice [1]: "
  read -r WT
  local wtype="agent"
  case "$WT" in
    2) wtype="treasury" ;;
    3) wtype="escrow" ;;
  esac

  local body
  body=$(make_json "wallet_type" "$wtype" "label" "$W_LABEL")

  info "Creating ${wtype} wallet (Solana)..."
  api_call POST /wallets "$body"

  if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
    local wid waddr
    wid=$(json_field "id")
    waddr=$(json_field "address")
    printf "\n"
    ok "Wallet created!"
    printf "  ${DIM}  Type:    ${NC}${wtype} (Solana)\n"
    printf "  ${DIM}  Label:   ${NC}${W_LABEL}\n"
    printf "  ${DIM}  ID:      ${NC}${CYAN}${wid}${NC}\n"
    if [ -n "$waddr" ] && [ "$waddr" != "null" ] && [ "$waddr" != "None" ]; then
      printf "  ${DIM}  Address: ${NC}${BGREEN}${waddr}${NC}\n"
      printf "\n"
      info "Send SOL to this address to fund your wallet"
    fi
  else
    err "Failed (HTTP $HTTP_CODE): $(api_error)"
  fi
  pause
}

# ── Flow: List Wallets ────────────────────────────────────────────────────────
flow_list_wallets() {
  [ -z "$AW_TOKEN" ] && { err "Login first (option 2)"; pause; return; }

  printf "\n  ${BYELLOW}>> YOUR WALLETS${NC}\n"; sep

  api_call GET /wallets

  if [ "$HTTP_CODE" = "200" ]; then
    if [ -n "$PYTHON" ]; then
      printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys, json
d = json.load(sys.stdin)
ws = d.get('data', [])
if not ws:
    print('  No wallets yet. Create one with option 4.')
else:
    print(f'  {len(ws)} wallet(s):\n')
    for i, w in enumerate(ws, 1):
        label = w.get('label') or '(unlabeled)'
        wtype = w.get('wallet_type', 'solana')
        addr  = w.get('address') or 'generating...'
        wid   = str(w.get('id',''))
        print(f'  [{i}] {label}  ({wtype})')
        print(f'       Addr: {addr}')
        print(f'       ID:   {wid}')
        print()
" 2>/dev/null
    else
      printf '%s\n' "$RESPONSE"
    fi
  else
    err "Could not load wallets (HTTP $HTTP_CODE): $(api_error)"
  fi
  pause
}

# ── Helper: pick a wallet interactively → sets SELECTED_WALLET_ID ─────────────
select_wallet() {
  SELECTED_WALLET_ID=""
  api_call GET /wallets
  [ "$HTTP_CODE" != "200" ] && { err "Could not load wallets."; return 1; }

  if [ -n "$PYTHON" ]; then
    local count
    count=$(printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys,json; d=json.load(sys.stdin); print(len(d.get('data',[])))
" 2>/dev/null)
    if [ "$count" = "0" ] || [ -z "$count" ]; then
      err "No wallets found. Create one first (option 4)."; return 1
    fi
    printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys, json
d = json.load(sys.stdin)
for i, w in enumerate(d.get('data', []), 1):
    label = w.get('label') or '(unlabeled)'
    wtype = w.get('wallet_type', 'solana')
    addr  = (w.get('address') or 'N/A')[:22]
    print(f'  [{i}] {label}  ({wtype})  {addr}...')
" 2>/dev/null
    printf "  ${YELLOW}>>${NC} Choice: "
    read -r W_IDX
    SELECTED_WALLET_ID=$(printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys, json
d = json.load(sys.stdin)
ws = d.get('data', [])
try:
    idx = int('${W_IDX}') - 1
    if 0 <= idx < len(ws): print(ws[idx]['id'])
    else: print('')
except: print('')
" 2>/dev/null)
  else
    # No Python — show raw and ask for wallet ID directly
    printf '%s\n' "$RESPONSE"
    printf "  ${YELLOW}>>${NC} Paste wallet ID: "
    read -r SELECTED_WALLET_ID
  fi

  [ -z "$SELECTED_WALLET_ID" ] && { err "Invalid selection."; return 1; }
  return 0
}

# ── Flow: Check Balance ───────────────────────────────────────────────────────
flow_balance() {
  [ -z "$AW_TOKEN" ] && { err "Login first (option 2)"; pause; return; }

  printf "\n  ${BYELLOW}>> WALLET BALANCE${NC}\n"; sep
  printf "  Select wallet:\n"
  select_wallet || { pause; return; }

  info "Fetching balance..."
  api_call GET "/wallets/${SELECTED_WALLET_ID}/balance"

  if [ "$HTTP_CODE" = "200" ]; then
    printf "\n"
    if [ -n "$PYTHON" ]; then
      printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys, json
d = json.load(sys.stdin)
sol  = float(d.get('sol_balance', 0) or 0)
lam  = d.get('lamports', 0) or 0
addr = d.get('address', 'N/A')
print(f'  Address : {addr}')
print(f'  Balance : {sol:.6f} SOL  ({lam} lamports)')
tokens = d.get('token_balances', [])
if tokens:
    print('  Tokens:')
    for t in tokens:
        mint = (t.get('mint') or '?')[:16] + '...'
        amt  = t.get('amount', 0)
        print(f'    {mint}  {amt}')
" 2>/dev/null
    else
      printf '%s\n' "$RESPONSE"
    fi
  else
    err "Failed (HTTP $HTTP_CODE): $(api_error)"
  fi
  pause
}

# ── Flow: Send SOL ────────────────────────────────────────────────────────────
flow_send() {
  [ -z "$AW_TOKEN" ] && { err "Login first (option 2)"; pause; return; }

  printf "\n  ${BYELLOW}>> SEND SOL${NC}\n"; sep
  info "Requires a funded Solana wallet."
  printf "\n"

  printf "  Select source wallet:\n"
  select_wallet || { pause; return; }
  local src_id="$SELECTED_WALLET_ID"

  prompt "Recipient Solana address" TO_ADDR
  prompt "Amount in SOL (e.g. 0.01)" AMOUNT_SOL
  prompt "Memo (optional, Enter to skip)" TX_MEMO

  local ikey="aw-$(date +%s)-$$"
  local body
  if [ -n "$TX_MEMO" ]; then
    body=$(make_json "from_wallet_id" "$src_id" "to_address" "$TO_ADDR" \
      "amount_sol" "$AMOUNT_SOL" "memo" "$TX_MEMO" "idempotency_key" "$ikey")
  else
    body=$(make_json "from_wallet_id" "$src_id" "to_address" "$TO_ADDR" \
      "amount_sol" "$AMOUNT_SOL" "idempotency_key" "$ikey")
  fi

  info "Submitting transaction..."
  api_call POST /transactions/transfer-sol "$body"

  if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
    local tx_id sig txstatus
    tx_id=$(json_field "id")
    sig=$(json_field "signature")
    txstatus=$(json_field "status")
    printf "\n"
    ok "Transaction submitted!"
    printf "  ${DIM}  TX ID:  ${NC}${CYAN}${tx_id}${NC}\n"
    printf "  ${DIM}  Status: ${NC}${txstatus}\n"
    if [ -n "$sig" ] && [ "$sig" != "null" ] && [ "$sig" != "None" ]; then
      printf "  ${DIM}  Sig:    ${NC}${BGREEN}${sig}${NC}\n"
    fi
  else
    err "Failed (HTTP $HTTP_CODE): $(api_error)"
  fi
  pause
}

# ── Flow: Create Escrow ───────────────────────────────────────────────────────
flow_create_escrow() {
  [ -z "$AW_TOKEN" ] && { err "Login first (option 2)"; pause; return; }

  printf "\n  ${BYELLOW}>> CREATE ESCROW${NC}\n"; sep
  info "Funds locked until you release (to recipient) or refund (back to you)."
  printf "\n"

  printf "  Select funder wallet:\n"
  select_wallet || { pause; return; }
  local funder_id="$SELECTED_WALLET_ID"

  prompt "Recipient Solana address" ESC_RECIP
  prompt "Amount in SOL (e.g. 0.5)" ESC_SOL
  printf "  ${YELLOW}>>${NC} ${BOLD}Expiry in hours${NC} [24]: "
  read -r ESC_EXP
  ESC_EXP="${ESC_EXP:-24}"

  local body
  body=$(make_json "funder_wallet_id" "$funder_id" "recipient_address" "$ESC_RECIP" \
    "amount_sol" "$ESC_SOL" "expires_in_hours" "$ESC_EXP")

  info "Creating escrow..."
  api_call POST /escrow "$body"

  if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
    local eid estatus eaddr
    eid=$(json_field "id")
    estatus=$(json_field "status")
    eaddr=$(json_field "escrow_address")
    printf "\n"
    ok "Escrow created!"
    printf "  ${DIM}  Escrow ID:  ${NC}${CYAN}${eid}${NC}\n"
    printf "  ${DIM}  Status:     ${NC}${estatus}\n"
    printf "  ${DIM}  Amount:     ${NC}${ESC_SOL} SOL\n"
    printf "  ${DIM}  Recipient:  ${NC}${ESC_RECIP}\n"
    printf "  ${DIM}  Expires in: ${NC}${ESC_EXP}h\n"
    [ -n "$eaddr" ] && [ "$eaddr" != "null" ] && \
      printf "  ${DIM}  On-chain:   ${NC}${BGREEN}${eaddr}${NC}\n"
    printf "\n"
    info "Use option 9 to release or refund this escrow"
  else
    err "Failed (HTTP $HTTP_CODE): $(api_error)"
  fi
  pause
}

# ── Flow: Manage Escrow ───────────────────────────────────────────────────────
flow_manage_escrow() {
  [ -z "$AW_TOKEN" ] && { err "Login first (option 2)"; pause; return; }

  printf "\n  ${BYELLOW}>> MANAGE ESCROW${NC}\n"; sep

  api_call GET /escrow
  [ "$HTTP_CODE" != "200" ] && { err "Could not load escrows (HTTP $HTTP_CODE)"; pause; return; }

  if [ -n "$PYTHON" ]; then
    local count
    count=$(printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys,json; d=json.load(sys.stdin); print(len(d.get('data',[])))
" 2>/dev/null)
    if [ "$count" = "0" ] || [ -z "$count" ]; then
      info "No escrows found. Create one with option 8."; pause; return
    fi
    printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys, json
d = json.load(sys.stdin)
for i, e in enumerate(d.get('data', []), 1):
    eid    = str(e.get('id',''))[:8] + '...'
    sol    = e.get('amount_lamports', 0) / 1e9
    status = e.get('status', '?')
    recip  = (e.get('recipient_address') or '?')[:22] + '...'
    print(f'  [{i}] {eid}  |  {sol:.4f} SOL  |  {status}')
    print(f'       Recipient: {recip}')
    print()
" 2>/dev/null
    printf "  ${YELLOW}>>${NC} Select escrow: "
    read -r E_IDX
    local escrow_id
    escrow_id=$(printf '%s' "$RESPONSE" | "$PYTHON" -c "
import sys, json
d = json.load(sys.stdin)
es = d.get('data', [])
try:
    idx = int('${E_IDX}') - 1
    if 0 <= idx < len(es): print(es[idx]['id'])
    else: print('')
except: print('')
" 2>/dev/null)
  else
    printf '%s\n' "$RESPONSE"
    printf "  ${YELLOW}>>${NC} Paste escrow ID: "
    read -r escrow_id
  fi

  [ -z "$escrow_id" ] && { err "Invalid selection."; pause; return; }

  printf "\n"
  printf "  ${BOLD}Action:${NC}\n"
  printf "  ${YELLOW}[1]${NC} ${BGREEN}Release${NC} — send to recipient\n"
  printf "  ${YELLOW}[2]${NC} ${YELLOW}Refund${NC}  — return to funder\n"
  printf "  ${YELLOW}[3]${NC} Dispute — flag for arbiter\n"
  printf "  ${YELLOW}>>${NC} Choice: "
  read -r ACT

  local action
  case "$ACT" in
    1) action="release" ;;
    2) action="refund" ;;
    3) action="dispute" ;;
    *) err "Invalid choice"; pause; return ;;
  esac

  local reason="" body
  if [ "$action" = "dispute" ]; then prompt "Reason" reason; fi
  if [ -n "$reason" ]; then
    body=$(make_json "action" "$action" "reason" "$reason")
  else
    body=$(make_json "action" "$action")
  fi

  info "Executing ${action}..."
  api_call POST "/escrow/${escrow_id}/action" "$body"

  if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
    printf "\n"
    ok "Escrow ${action} complete! Status: $(json_field status)"
  else
    err "Failed (HTTP $HTTP_CODE): $(api_error)"
  fi
  pause
}

# ── Main Interactive Menu ─────────────────────────────────────────────────────
cmd_menu() {
  if ! command -v curl >/dev/null 2>&1; then
    printf "${RED}Error: curl is required.${NC}\n"; exit 1
  fi

  load_session
  show_intro

  while true; do
    print_menu_header

    printf "  ${BOLD}ACCOUNT${NC}\n"
    printf "  ${YELLOW}[1]${NC} Register new account\n"
    printf "  ${YELLOW}[2]${NC} Login\n"
    [ -n "$AW_TOKEN" ] && printf "  ${YELLOW}[3]${NC} Logout\n"
    printf "\n"

    printf "  ${BOLD}WALLETS${NC}\n"
    printf "  ${YELLOW}[4]${NC} Create wallet\n"
    printf "  ${YELLOW}[5]${NC} List wallets\n"
    printf "  ${YELLOW}[6]${NC} Check balance\n"
    printf "\n"

    printf "  ${BOLD}PAYMENTS${NC}\n"
    printf "  ${YELLOW}[7]${NC} Send SOL\n"
    printf "\n"

    printf "  ${BOLD}ESCROW${NC}\n"
    printf "  ${YELLOW}[8]${NC} Create escrow\n"
    printf "  ${YELLOW}[9]${NC} Release / Refund escrow\n"
    printf "\n"

    sep
    printf "  ${YELLOW}[h]${NC} Help   ${YELLOW}[q]${NC} Quit\n\n"
    printf "  ${BYELLOW}>>${NC} ${BOLD}command:${NC} "
    read -r CHOICE

    case "$CHOICE" in
      1) flow_register ;;
      2) flow_login ;;
      3) flow_logout ;;
      4) flow_create_wallet ;;
      5) flow_list_wallets ;;
      6) flow_balance ;;
      7) flow_send ;;
      8) flow_create_escrow ;;
      9) flow_manage_escrow ;;
      h|H|help) cmd_help; printf "\n"; pause ;;
      q|Q|quit|exit) printf "\n  ${DIM}[session saved — bye]${NC}\n\n"; exit 0 ;;
      "") ;;
      *) err "Unknown: '${CHOICE}'. Enter 1-9, h, or q." ;;
    esac
  done
}

# ── Help ──────────────────────────────────────────────────────────────────────
cmd_help() {
  printf "\n"
  printf "  ${BYELLOW}// AGENT WALLET${NC}  ${DIM}v0.4.0${NC}\n\n"

  printf "  ${BOLD}INTERACTIVE${NC}\n"
  printf "  ${YELLOW}./aw${NC}            ${DIM}·${NC}  Guided menu (register, wallet, escrow, pay)\n"
  printf "  ${YELLOW}./aw menu${NC}       ${DIM}·${NC}  Same as above\n\n"

  printf "  ${BOLD}GETTING STARTED${NC}\n"
  printf "  ${YELLOW}./aw setup${NC}      ${DIM}·${NC}  First-time setup after git clone\n"
  printf "  ${YELLOW}./aw start${NC}      ${DIM}·${NC}  Start API + PostgreSQL + Redis\n"
  printf "  ${YELLOW}./aw status${NC}     ${DIM}·${NC}  Check if everything is running\n"
  printf "  ${YELLOW}./aw stop${NC}       ${DIM}·${NC}  Stop all services\n\n"

  printf "  ${BOLD}DEVELOPMENT${NC}\n"
  printf "  ${YELLOW}./aw logs${NC}       ${DIM}·${NC}  Tail API logs\n"
  printf "  ${YELLOW}./aw test${NC}       ${DIM}·${NC}  Run all 110 tests\n"
  printf "  ${YELLOW}./aw lint${NC}       ${DIM}·${NC}  Check code style (ruff)\n"
  printf "  ${YELLOW}./aw shell${NC}      ${DIM}·${NC}  Bash inside API container\n"
  printf "  ${YELLOW}./aw restart${NC}    ${DIM}·${NC}  Restart API after changes\n\n"

  printf "  ${BOLD}DATABASE${NC}\n"
  printf "  ${YELLOW}./aw db${NC}         ${DIM}·${NC}  PostgreSQL shell\n"
  printf "  ${YELLOW}./aw migrate${NC}    ${DIM}·${NC}  Run Alembic migrations\n"
  printf "  ${YELLOW}./aw clean${NC}      ${DIM}·${NC}  Full reset (deletes all data)\n\n"

  printf "  ${BOLD}API${NC}\n"
  printf "  ${YELLOW}./aw health${NC}     ${DIM}·${NC}  Check API health\n"
  printf "  ${YELLOW}./aw open${NC}       ${DIM}·${NC}  Open Swagger docs\n\n"

  printf "  ${DIM}Tip: AW_API=https://api.agentwallet.fun ./aw  (use production)${NC}\n\n"
}

# ── Dev commands ──────────────────────────────────────────────────────────────
cmd_setup()   { bash setup.sh; }
cmd_start()   {
  printf "${BGREEN}Starting services...${NC}\n"
  docker compose up -d postgres redis api
  printf "${BGREEN}[OK]${NC} http://localhost:8000  |  docs: http://localhost:8000/docs\n"
}
cmd_stop()    { printf "${YELLOW}Stopping...${NC}\n"; docker compose down; ok "Done."; }
cmd_restart() { docker compose restart api; ok "API restarted."; }
cmd_logs()    { printf "${DIM}Ctrl+C to exit${NC}\n"; docker compose logs -f api; }
cmd_test()    { pip install -e ".[dev]" -q; pytest packages/api/tests -v --tb=short; }
cmd_lint()    { command -v ruff >/dev/null 2>&1 || pip install ruff -q; ruff check packages/api/agentwallet/; }
cmd_shell()   { docker compose exec api bash; }
cmd_db()      { docker compose exec postgres psql -U agentwallet; }
cmd_migrate() { docker compose exec api alembic upgrade head; }
cmd_health()  {
  curl -s http://localhost:8000/health \
    | { [ -n "$PYTHON" ] && "$PYTHON" -m json.tool || cat; } 2>/dev/null \
    || err "API not reachable. Run: ./aw start"
}
cmd_open() {
  local URL="http://localhost:8000/docs"
  if command -v xdg-open >/dev/null 2>&1; then xdg-open "$URL"
  elif command -v open >/dev/null 2>&1;    then open "$URL"
  else printf "${YELLOW}Open: $URL${NC}\n"; fi
}
cmd_status() {
  printf "\n  ${BOLD}Service Status${NC}\n\n"
  if command -v curl >/dev/null 2>&1; then
    local s
    s=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health 2>/dev/null || echo "000")
    if [ "$s" = "200" ]; then printf "  ${BGREEN}[UP]${NC}   API   http://localhost:8000\n"
    else                       printf "  ${RED}[DOWN]${NC} API   (HTTP $s)\n"; fi
  fi
  if docker ps --format "{{.Names}}\t{{.Status}}" 2>/dev/null | grep -q agentwallet; then
    docker ps --format "{{.Names}}\t{{.Status}}" 2>/dev/null | grep agentwallet | while read -r name status; do
      printf "  ${BGREEN}[UP]${NC}   %s  %s\n" "$(printf '%s' "$name" | sed 's/agentwallet-//;s/-1//')" "$status"
    done
  else
    printf "  ${RED}[DOWN]${NC} No containers running — run: ${YELLOW}./aw start${NC}\n"
  fi
  printf "\n"
}
cmd_clean() {
  printf "${RED}WARNING: Deletes all local data.${NC}\n"
  printf "Press Enter to continue or Ctrl+C to cancel...\n"; read -r _
  docker compose down -v
  ok "Clean done. Run ./aw setup to start fresh."
}
cmd_unknown() { err "Unknown command: $CMD"; printf "  Run ${YELLOW}./aw help${NC}\n"; exit 1; }

# ── Dispatch ──────────────────────────────────────────────────────────────────
case "$CMD" in
  menu)             cmd_menu ;;
  help|--help|-h)   cmd_help ;;
  setup)            cmd_setup ;;
  start)            cmd_start ;;
  stop)             cmd_stop ;;
  restart)          cmd_restart ;;
  status)           cmd_status ;;
  logs)             cmd_logs ;;
  test)             cmd_test ;;
  lint)             cmd_lint ;;
  shell)            cmd_shell ;;
  db)               cmd_db ;;
  migrate)          cmd_migrate ;;
  health)           cmd_health ;;
  open)             cmd_open ;;
  clean)            cmd_clean ;;
  *)                cmd_unknown ;;
esac
